# 1 高速缓冲

高速缓存是内核中的一个数据结构，用于暂时存储硬盘中的数据，降低对硬盘的存取频率（每次存取都会因为磁盘传输效率低，而使系统响应时间变长）。对于读操作使用**数据缓冲以及提前写**策略，写操作使用**延迟写**策略。

数据缓冲（以及提前写）策略是将硬盘中某块数据在缓冲区内备份。每次读操作时会优先从数据缓冲区尝试读取。

延迟写策略是数据写操作优先对缓冲区对应块进行读写，当块满足相应条件后，再进行写。


# 2 缓冲区分配算法
## 2.1 缓冲头部
缓冲区是高速缓冲的基本单位，且**唯一**对应于磁盘中的块，其由缓冲头部（buffer header)和数据存储数组组成，缓冲头部唯一标识一个缓冲区，包含：设备号、块号、状态、数据存储区指针、以及用于管理缓冲区的两对指针。
![图2-1](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210071831285.png)

|     字段     | 作用                                                         |
|:------------:| ------------------------------------------------------------ |
| 设备号与块号 | 表示缓冲区映射的硬盘存储块                                   |
|  数据域指针  | 指向实际的数据                                               |
|     状态     | 存在“上锁（忙）”和“开锁（闲）”两种状态，用于保证数据的完整性 |
| 散列队列指针 | 可以通过设备号和块号计算出缓冲区的地址                       |
|  空闲表指针  | 管理空闲的缓冲区                                             |

缓冲区分配算法是通过对缓冲头部操作实现的。下面介绍由缓冲区构成的缓冲池.

## 2.2 缓冲池结构
### 2.2.1 散列队列
缓冲池的基本结构，当进程访问硬盘存储块时，会优先从**高速缓冲**中读取数据。为了不在查找上损失性能，所以使用**以设备号和块号散列的队列**，可以相对较快的寻找到需要的存储块。例如：图2-2，blkno 0 mod 4代表**块号取余得0**的块。

![图2-2](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210071851044.png)


### 2.2.2 空闲表
空闲表是内核维护的一个空闲状态的缓冲区双向循环队列。对空闲表的操作使用**最近最少算法**。每当内核释放一个缓冲区，即由“忙”转换为”空闲“时会将空闲的缓冲区插入到队列的尾部（也会出现例外，见..）。当内核需要一个空闲的缓冲区时，既可以从头部获取，也可以获取特定的空闲缓冲区。
![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210071905295.png)

需要注意的是，每个缓冲区总是存在于一个散列队列中，可能存在于空闲表中，这取决于缓冲区的状态。

## 2.3 缓冲区的检索
读、写磁盘块的算法使用算法getblk来对池中的缓冲区进行分配。使用算法brelse来释放缓冲区。
``` c
算法 getblk
输入：文件系统号 块号
输出：现在能被磁盘块使用的上了锁的缓冲区
{
    while(没有找到缓冲区) {
        if(块在散列队列中) {
            if(块忙) { // 第5种情况
                sleep(等待"该缓冲区变为空闲"事件);
                continue; // 回到while循环
            }
            为缓冲区标记上"忙"（上锁）； // 第1种情况
            从空闲表上摘下缓冲区;
            return (缓冲区);
        } else {
            if(空闲表上无缓冲区) { // 第4种情况
                sleep(等待"任何缓冲变为空闲"事件);
                continue; // 回到循环
            }
            从空闲表上摘下缓冲区;
            if(缓冲区标记着延迟写) { // 第3种情况
                缓冲区异步写到磁盘上;
                continue;
            }
            从旧散列队列种摘下缓冲区; // 第2种情况
            把缓冲区插入到新散列队列;
            return (缓冲区);
        }
    }
}
```
```c
算法 brelse
输入： 上锁态的缓冲区
输出：无
{
    唤醒正在等待"无论哪个缓冲区变为空闲"事件的所有进程;
    唤醒正在等待"当前缓冲区变为空闲"事件的所有进程;
    提高处理机执行级别以封锁中断;
    if(缓冲区内容有效且缓冲区非"旧") {
        将缓冲区插入空闲表尾部;
    } else {
        将缓冲区插入空闲表头部;
    }
    降低处理及执行级别以允许中断；
    缓冲区解锁;
}
```
算法getblk中出现的5种情况：
1. 情况1：块在散列队列中，并且缓冲区为空闲。
2. 情况2：块不在队列中，从空闲表中分配一个缓冲区。
3. 情况3： 在情况2的基础上，发现缓冲区标识了“延迟写”。
4. 情况4：块不在队列中，并且空闲缓冲区表已空。
5. 情况5：块在散列队列中，并且缓冲区为忙。

### 2.3.1 情况1
情况1是最简单的情况：块在散列队列中，并且缓冲区为空闲。getblk算法将对应的缓冲区上锁，然后从空闲表上摘下。 
例如：获取4号逻辑块，首先算法发现散列队列中存在，且4号逻辑块对应的缓冲区在空闲表中（缓冲区空闲）。然后非常简单的将4号从空闲表上摘下，然后返回一个上锁的缓冲区。
![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091104639.png)

![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091107618.png)

### 2.3.2 情况2
情况2：块不在队列中，从空闲表中分配一个缓冲区。
此时getblk算法会申请从空闲表中分配一个缓冲区（隐含假设：空闲区不为空），然后，修改缓冲区各个字段（将块号、设备号、以及的各种指针修改）。
**注意**：这里只是对缓冲区的分配，不涉及磁盘读写，磁盘读写会使用到getblk算法。
![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091114948.png)

### 2.3.3 情况3
情况3：在情况2的基础上，发现缓冲区标识了“延迟写”。
情况3就是说算法发现分配的缓冲区是需要**延迟写**的，那么意味着磁盘的数据是旧的，需要将缓冲区的数据写到磁盘内。因此，getblk算法会执行异步写操作，然后会重新尝试获取空闲队列的下一个缓冲区。

补充：当异步操作结束后，内核处理磁盘中断，内核会首先将缓冲区内容标记为旧，然后调用brelse算法处理刚才用于读写的缓冲区，将其插入到空闲队列头部。
如果异步IO操作发生异常中断，同样意味着没有“真正”使用过该缓冲区.
为什么会插入头部的呢？原因在于没有“真正”使用过的该缓冲区，不符合**最近最少**算法。试想下如果插入到尾部，会经过额外的一段事件从尾部移动到头部。


例如： 算法尝试获取3，发现需要异步写，然后获取5，发现需要异步写，最后终于尝试4，不需要异步写（此时其实就是情况2）,随后操作就如同情况2。
![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091121666.png)
### 2.3.4 情况4
情况4：块不在队列中，并且空闲缓冲区表已空。
因为缺少资源。此时会让当前进程睡眠，等待**任意**一个缓冲区被释放的事件。
这里需要注意的是，唤醒后的第一部操作，并不是去从空闲表上获取一个缓冲区。而是去检查的散列队列中，是否有自己想要的块。因为进程的调度问题，所以可能之前有进程已经完成了分配操作，见图....。
![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091622098.png)

![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091622439.png)

### 2.3.5 情况5
情况5：块在散列队列中，并且缓冲区为忙。
这是最为复杂的一种情况，因为要考虑进程之间的竞争关系。当块（缓冲区）为情况5的条件下，意味着缓冲区正在被一个进程使用。当另外一个进程需要该块时，会睡眠，等待”当前块闲置“的事件。
进程唤醒后需要判断两个条件：
1. 当前块仍然存在于队列中
2. 缓冲区已经空闲
条件1：是因为可能有“任意缓冲区空闲”的进程提前将该块移动到其他队列中。
条件2：是因为可能有另外一个"当前缓冲区空闲"的进程将缓冲区变为忙。
当然，这一切判断，在算法内都是使用continue进入下次循环实现的。
例如：
![](https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091644521.png)

最后，缓冲区分配的算法必须是安全的，即**保证进程不永远睡眠**，最终都能得到一个缓冲区。前面描述的算法整个过程是在内核的操作下进行，即核心态下，内核总能保证一个进程会获得需要的块。唯一不受控制的地方是在情况3的情况下，延迟写的异步IO，试想如果磁盘设备因故障永远不发生中断，那么缓冲区永远不会被释放，意味着等待它的所有进程都会一直睡眠下去，所以磁盘驱动程序有义务发送异常给内核，内核进行处理。


## 2.4 读磁盘块与写磁盘块
前面讲述了关于缓冲区的分配，并没有真正涉及磁盘块的读写。缓冲区的分配是构成磁盘读写的基础，下面将介绍关于读写块的内容。
### 2.4.1 bread、breada算法
bread和breada都是读磁盘块的算法，但他们之间有所区别，稍后会进行介绍。
```c
算法 bread // 读块
输入： 文件系统块号
输出：含有数据的缓冲区
{
    得到该块的缓冲区（算法getblk);
    if(缓冲区数据有效)
        return (缓冲区);
    启动磁盘读；
    sleep(等待"读盘完成"事件);
    return (缓冲区);
}
```
通过bread算法就实现了磁盘的读写。但是有时内核会预料到对另外一个磁盘块的需要（例如：文件连续读），此时，内核可以异步请求第二个IO，改善性能。而这个是由breada实现的。
```c
算法 breada // 读块与提前读
输入：立即读的文件系统块号
     异步读的文件系统块号
输入： 含有可立即读的数据的缓冲区
{
    if(第一个块不再高速缓冲) {
        为第一块获取缓冲区（算法getblk);
        if(缓冲区数据无效)
            启动磁盘读;
    }
    if(第二块不在高速缓存中) {
        为第二块获得缓冲区(算法getblk);
        if(缓冲区数据有效) {
            释放缓冲区(算法brelse);
        } else {
            启动磁盘读;
        }
    }
    if(第一块本来就在高速缓冲中) {
        读第一块（算法bread);
        return (缓冲区);
    }
    sleep(第一个缓冲区包含有效数据的事件);
    return (缓冲区);
}
```

### 2.4.2 bwrite算法

bwrite算法是写磁盘块的算法。与前面类似。
```c
算法 bwrite // 写块
输入： 缓冲区
输出： 无
{
    启动磁盘写;
    if(IO同步) {
        sleep(等待IO完成事件);
        释放缓冲区（算法brelse）;
    } else if (缓冲区标记延迟写) 
        为缓冲区做标记以放到空闲表头部;// 这里标记就是前面"旧".
}
```

最后，因为有提前读与延迟写磁盘块这两个异步I/O操作，所以才发生内核从一个中断处理程序中调用brelse的情形。由于brelse要把缓冲区放到空闲表上，所以它必须在对缓冲区空闲表进行操作的任何过程中都禁止中断。

关于缓冲区优点参见原书3.5。


