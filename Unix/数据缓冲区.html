<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1 高速缓冲 | Mrokooの知识库</title>
    <meta name="description" content="mrokoo note ">
    <link rel="stylesheet" href="/note/assets/style.f4ab8da1.css">
    <link rel="modulepreload" href="/note/assets/app.e06fd376.js">
    <link rel="modulepreload" href="/note/assets/Unix_数据缓冲区.md.fa45b0bd.lean.js">
    
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-c6a644e1><!--[--><!--]--><!--[--><span tabindex="-1" data-v-151f2593></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-151f2593> Skip to content </a><!--]--><!----><header class="VPNav" data-v-c6a644e1 data-v-a71a30f1><div class="VPNavBar has-sidebar" data-v-a71a30f1 data-v-6f1d18b5><div class="container" data-v-6f1d18b5><div class="VPNavBarTitle has-sidebar" data-v-6f1d18b5 data-v-d5925166><a class="title" href="/note/" data-v-d5925166><!--[--><!--]--><!----><!--[-->Mrokooの知识库<!--]--><!--[--><!--]--></a></div><div class="content" data-v-6f1d18b5><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6f1d18b5 data-v-f83db6ba><span id="main-nav-aria-label" class="visually-hidden" data-v-f83db6ba>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/note/doc/" data-v-f83db6ba data-v-47a2263e data-v-3c355974><!--[-->文档<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/note/rnote/" data-v-f83db6ba data-v-47a2263e data-v-3c355974><!--[-->笔记<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6f1d18b5 data-v-a3e7452b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-a3e7452b data-v-1899cd41 data-v-086e8519><span class="check" data-v-086e8519><span class="icon" data-v-086e8519><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-1899cd41><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-1899cd41><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-6f1d18b5 data-v-e4361c82 data-v-6ffb57d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6ffb57d3><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-6ffb57d3><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-6ffb57d3><div class="VPMenu" data-v-6ffb57d3 data-v-1c5d0cfc><!----><!--[--><!--[--><!----><div class="group" data-v-e4361c82><div class="item appearance" data-v-e4361c82><p class="label" data-v-e4361c82>Appearance</p><div class="appearance-action" data-v-e4361c82><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-e4361c82 data-v-1899cd41 data-v-086e8519><span class="check" data-v-086e8519><span class="icon" data-v-086e8519><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-1899cd41><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-1899cd41><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6f1d18b5 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-c6a644e1 data-v-aac27d5e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-aac27d5e><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-aac27d5e><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-aac27d5e>Menu</span></button><a class="top-link" href="#" data-v-aac27d5e> Return to top </a></div><aside class="VPSidebar" data-v-c6a644e1 data-v-f332cb62><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-f332cb62><span class="visually-hidden" id="sidebar-aria-label" data-v-f332cb62> Sidebar Navigation </span><!--[--><div class="group" data-v-f332cb62><section class="VPSidebarGroup" data-v-f332cb62 data-v-35f99ef5><div class="title" data-v-35f99ef5><h2 class="title-text" data-v-35f99ef5>Unix程序设计</h2><div class="action" data-v-35f99ef5><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-35f99ef5><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-35f99ef5><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-35f99ef5><!--[--><!--[--><a class="VPLink link link" href="/note/Unix/" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>目录</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link active" href="/note/Unix/%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>数据缓冲区</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/note/Unix/%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>文件内部表示</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-c6a644e1 data-v-c95df128><div class="VPDoc has-sidebar has-aside" data-v-c95df128 data-v-37ebe389><div class="container" data-v-37ebe389><div class="aside" data-v-37ebe389><div class="aside-curtain" data-v-37ebe389></div><div class="aside-container" data-v-37ebe389><div class="aside-content" data-v-37ebe389><div class="VPDocAside" data-v-37ebe389 data-v-afc4c1a1><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-afc4c1a1 data-v-2865c0b0><div class="content" data-v-2865c0b0><div class="outline-marker" data-v-2865c0b0></div><div class="outline-title" data-v-2865c0b0>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-2865c0b0><span class="visually-hidden" id="doc-outline-aria-label" data-v-2865c0b0> Table of Contents for current page </span><ul class="root" data-v-2865c0b0 data-v-1188541a><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-afc4c1a1></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-37ebe389><div class="content-container" data-v-37ebe389><!--[--><!--]--><main class="main" data-v-37ebe389><div style="position:relative;" class="vp-doc _note_Unix_%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA" data-v-37ebe389><div><h1 id="_1-高速缓冲" tabindex="-1">1 高速缓冲 <a class="header-anchor" href="#_1-高速缓冲" aria-hidden="true">#</a></h1><p>高速缓存是内核中的一个数据结构，用于暂时存储硬盘中的数据，降低对硬盘的存取频率（每次存取都会因为磁盘传输效率低，而使系统响应时间变长）。对于读操作使用<strong>数据缓冲以及提前写</strong>策略，写操作使用<strong>延迟写</strong>策略。</p><p>数据缓冲（以及提前写）策略是将硬盘中某块数据在缓冲区内备份。每次读操作时会优先从数据缓冲区尝试读取。</p><p>延迟写策略是数据写操作优先对缓冲区对应块进行读写，当块满足相应条件后，再进行写。</p><h1 id="_2-缓冲区分配算法" tabindex="-1">2 缓冲区分配算法 <a class="header-anchor" href="#_2-缓冲区分配算法" aria-hidden="true">#</a></h1><h2 id="_2-1-缓冲头部" tabindex="-1">2.1 缓冲头部 <a class="header-anchor" href="#_2-1-缓冲头部" aria-hidden="true">#</a></h2><p>缓冲区是高速缓冲的基本单位，且<strong>唯一</strong>对应于磁盘中的块，其由缓冲头部（buffer header)和数据存储数组组成，缓冲头部唯一标识一个缓冲区，包含：设备号、块号、状态、数据存储区指针、以及用于管理缓冲区的两对指针。 <img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210071831285.png" alt="图2-1"></p><table><thead><tr><th style="text-align:center;">字段</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center;">设备号与块号</td><td>表示缓冲区映射的硬盘存储块</td></tr><tr><td style="text-align:center;">数据域指针</td><td>指向实际的数据</td></tr><tr><td style="text-align:center;">状态</td><td>存在“上锁（忙）”和“开锁（闲）”两种状态，用于保证数据的完整性</td></tr><tr><td style="text-align:center;">散列队列指针</td><td>可以通过设备号和块号计算出缓冲区的地址</td></tr><tr><td style="text-align:center;">空闲表指针</td><td>管理空闲的缓冲区</td></tr></tbody></table><p>缓冲区分配算法是通过对缓冲头部操作实现的。下面介绍由缓冲区构成的缓冲池.</p><h2 id="_2-2-缓冲池结构" tabindex="-1">2.2 缓冲池结构 <a class="header-anchor" href="#_2-2-缓冲池结构" aria-hidden="true">#</a></h2><h3 id="_2-2-1-散列队列" tabindex="-1">2.2.1 散列队列 <a class="header-anchor" href="#_2-2-1-散列队列" aria-hidden="true">#</a></h3><p>缓冲池的基本结构，当进程访问硬盘存储块时，会优先从<strong>高速缓冲</strong>中读取数据。为了不在查找上损失性能，所以使用<strong>以设备号和块号散列的队列</strong>，可以相对较快的寻找到需要的存储块。例如：图2-2，blkno 0 mod 4代表<strong>块号取余得0</strong>的块。</p><p><img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210071851044.png" alt="图2-2"></p><h3 id="_2-2-2-空闲表" tabindex="-1">2.2.2 空闲表 <a class="header-anchor" href="#_2-2-2-空闲表" aria-hidden="true">#</a></h3><p>空闲表是内核维护的一个空闲状态的缓冲区双向循环队列。对空闲表的操作使用<strong>最近最少算法</strong>。每当内核释放一个缓冲区，即由“忙”转换为”空闲“时会将空闲的缓冲区插入到队列的尾部（也会出现例外，见..）。当内核需要一个空闲的缓冲区时，既可以从头部获取，也可以获取特定的空闲缓冲区。 <img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210071905295.png" alt=""></p><p>需要注意的是，每个缓冲区总是存在于一个散列队列中，可能存在于空闲表中，这取决于缓冲区的状态。</p><h2 id="_2-3-缓冲区的检索" tabindex="-1">2.3 缓冲区的检索 <a class="header-anchor" href="#_2-3-缓冲区的检索" aria-hidden="true">#</a></h2><p>读、写磁盘块的算法使用算法getblk来对池中的缓冲区进行分配。使用算法brelse来释放缓冲区。</p><div class="language-c"><button class="copy"></button><span class="lang">c</span><pre><code><span class="line"><span style="color:#A6ACCD;">算法 getblk</span></span>
<span class="line"><span style="color:#A6ACCD;">输入：文件系统号 块号</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：现在能被磁盘块使用的上了锁的缓冲区</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">while</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">没有找到缓冲区</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">块在散列队列中</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">块忙</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;"> // 第5种情况</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">等待</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">该缓冲区变为空闲</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">事件</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#89DDFF;">continue</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> // 回到while循环</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">            为缓冲区标记上</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">忙</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">（上锁）；</span><span style="color:#676E95;"> // 第1种情况</span></span>
<span class="line"><span style="color:#F07178;">            从空闲表上摘下缓冲区</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">空闲表上无缓冲区</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;"> // 第4种情况</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">等待</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">任何缓冲变为空闲</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">事件</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#89DDFF;">continue</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> // 回到循环</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">            从空闲表上摘下缓冲区</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区标记着延迟写</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;"> // 第3种情况</span></span>
<span class="line"><span style="color:#F07178;">                缓冲区异步写到磁盘上</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#89DDFF;">continue</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">            从旧散列队列种摘下缓冲区</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;"> // 第2种情况</span></span>
<span class="line"><span style="color:#F07178;">            把缓冲区插入到新散列队列</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><div class="language-c"><button class="copy"></button><span class="lang">c</span><pre><code><span class="line"><span style="color:#A6ACCD;">算法 brelse</span></span>
<span class="line"><span style="color:#A6ACCD;">输入： 上锁态的缓冲区</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：无</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    唤醒正在等待</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">无论哪个缓冲区变为空闲</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">事件的所有进程</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    唤醒正在等待</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">当前缓冲区变为空闲</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">事件的所有进程</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    提高处理机执行级别以封锁中断</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区内容有效且缓冲区非</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">旧</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        将缓冲区插入空闲表尾部</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        将缓冲区插入空闲表头部</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    降低处理及执行级别以允许中断；</span></span>
<span class="line"><span style="color:#F07178;">    缓冲区解锁</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>算法getblk中出现的5种情况：</p><ol><li>情况1：块在散列队列中，并且缓冲区为空闲。</li><li>情况2：块不在队列中，从空闲表中分配一个缓冲区。</li><li>情况3： 在情况2的基础上，发现缓冲区标识了“延迟写”。</li><li>情况4：块不在队列中，并且空闲缓冲区表已空。</li><li>情况5：块在散列队列中，并且缓冲区为忙。</li></ol><h3 id="_2-3-1-情况1" tabindex="-1">2.3.1 情况1 <a class="header-anchor" href="#_2-3-1-情况1" aria-hidden="true">#</a></h3><p>情况1是最简单的情况：块在散列队列中，并且缓冲区为空闲。getblk算法将对应的缓冲区上锁，然后从空闲表上摘下。 例如：获取4号逻辑块，首先算法发现散列队列中存在，且4号逻辑块对应的缓冲区在空闲表中（缓冲区空闲）。然后非常简单的将4号从空闲表上摘下，然后返回一个上锁的缓冲区。 <img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091104639.png" alt=""></p><p><img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091107618.png" alt=""></p><h3 id="_2-3-2-情况2" tabindex="-1">2.3.2 情况2 <a class="header-anchor" href="#_2-3-2-情况2" aria-hidden="true">#</a></h3><p>情况2：块不在队列中，从空闲表中分配一个缓冲区。 此时getblk算法会申请从空闲表中分配一个缓冲区（隐含假设：空闲区不为空），然后，修改缓冲区各个字段（将块号、设备号、以及的各种指针修改）。 <strong>注意</strong>：这里只是对缓冲区的分配，不涉及磁盘读写，磁盘读写会使用到getblk算法。 <img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091114948.png" alt=""></p><h3 id="_2-3-3-情况3" tabindex="-1">2.3.3 情况3 <a class="header-anchor" href="#_2-3-3-情况3" aria-hidden="true">#</a></h3><p>情况3：在情况2的基础上，发现缓冲区标识了“延迟写”。 情况3就是说算法发现分配的缓冲区是需要<strong>延迟写</strong>的，那么意味着磁盘的数据是旧的，需要将缓冲区的数据写到磁盘内。因此，getblk算法会执行异步写操作，然后会重新尝试获取空闲队列的下一个缓冲区。</p><p>补充：当异步操作结束后，内核处理磁盘中断，内核会首先将缓冲区内容标记为旧，然后调用brelse算法处理刚才用于读写的缓冲区，将其插入到空闲队列头部。 如果异步IO操作发生异常中断，同样意味着没有“真正”使用过该缓冲区. 为什么会插入头部的呢？原因在于没有“真正”使用过的该缓冲区，不符合<strong>最近最少</strong>算法。试想下如果插入到尾部，会经过额外的一段事件从尾部移动到头部。</p><p>例如： 算法尝试获取3，发现需要异步写，然后获取5，发现需要异步写，最后终于尝试4，不需要异步写（此时其实就是情况2）,随后操作就如同情况2。 <img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091121666.png" alt=""></p><h3 id="_2-3-4-情况4" tabindex="-1">2.3.4 情况4 <a class="header-anchor" href="#_2-3-4-情况4" aria-hidden="true">#</a></h3><p>情况4：块不在队列中，并且空闲缓冲区表已空。 因为缺少资源。此时会让当前进程睡眠，等待<strong>任意</strong>一个缓冲区被释放的事件。 这里需要注意的是，唤醒后的第一部操作，并不是去从空闲表上获取一个缓冲区。而是去检查的散列队列中，是否有自己想要的块。因为进程的调度问题，所以可能之前有进程已经完成了分配操作，见图....。 <img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091622098.png" alt=""></p><p><img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091622439.png" alt=""></p><h3 id="_2-3-5-情况5" tabindex="-1">2.3.5 情况5 <a class="header-anchor" href="#_2-3-5-情况5" aria-hidden="true">#</a></h3><p>情况5：块在散列队列中，并且缓冲区为忙。 这是最为复杂的一种情况，因为要考虑进程之间的竞争关系。当块（缓冲区）为情况5的条件下，意味着缓冲区正在被一个进程使用。当另外一个进程需要该块时，会睡眠，等待”当前块闲置“的事件。 进程唤醒后需要判断两个条件：</p><ol><li>当前块仍然存在于队列中</li><li>缓冲区已经空闲 条件1：是因为可能有“任意缓冲区空闲”的进程提前将该块移动到其他队列中。 条件2：是因为可能有另外一个&quot;当前缓冲区空闲&quot;的进程将缓冲区变为忙。 当然，这一切判断，在算法内都是使用continue进入下次循环实现的。 例如： <img src="https://note-image-1302477034.cos.ap-chengdu.myqcloud.com/pic/202210091644521.png" alt=""></li></ol><p>最后，缓冲区分配的算法必须是安全的，即<strong>保证进程不永远睡眠</strong>，最终都能得到一个缓冲区。前面描述的算法整个过程是在内核的操作下进行，即核心态下，内核总能保证一个进程会获得需要的块。唯一不受控制的地方是在情况3的情况下，延迟写的异步IO，试想如果磁盘设备因故障永远不发生中断，那么缓冲区永远不会被释放，意味着等待它的所有进程都会一直睡眠下去，所以磁盘驱动程序有义务发送异常给内核，内核进行处理。</p><h2 id="_2-4-读磁盘块与写磁盘块" tabindex="-1">2.4 读磁盘块与写磁盘块 <a class="header-anchor" href="#_2-4-读磁盘块与写磁盘块" aria-hidden="true">#</a></h2><p>前面讲述了关于缓冲区的分配，并没有真正涉及磁盘块的读写。缓冲区的分配是构成磁盘读写的基础，下面将介绍关于读写块的内容。</p><h3 id="_2-4-1-bread、breada算法" tabindex="-1">2.4.1 bread、breada算法 <a class="header-anchor" href="#_2-4-1-bread、breada算法" aria-hidden="true">#</a></h3><p>bread和breada都是读磁盘块的算法，但他们之间有所区别，稍后会进行介绍。</p><div class="language-c"><button class="copy"></button><span class="lang">c</span><pre><code><span class="line"><span style="color:#A6ACCD;">算法 bread</span><span style="color:#676E95;"> // 读块</span></span>
<span class="line"><span style="color:#A6ACCD;">输入： 文件系统块号</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：含有数据的缓冲区</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    得到该块的缓冲区（算法getblk)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区数据有效</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    启动磁盘读；</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">等待</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">读盘完成</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">事件</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>通过bread算法就实现了磁盘的读写。但是有时内核会预料到对另外一个磁盘块的需要（例如：文件连续读），此时，内核可以异步请求第二个IO，改善性能。而这个是由breada实现的。</p><div class="language-c"><button class="copy"></button><span class="lang">c</span><pre><code><span class="line"><span style="color:#A6ACCD;">算法 breada</span><span style="color:#676E95;"> // 读块与提前读</span></span>
<span class="line"><span style="color:#A6ACCD;">输入：立即读的文件系统块号</span></span>
<span class="line"><span style="color:#A6ACCD;">     异步读的文件系统块号</span></span>
<span class="line"><span style="color:#A6ACCD;">输入： 含有可立即读的数据的缓冲区</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">第一个块不再高速缓冲</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        为第一块获取缓冲区（算法getblk)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区数据无效</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#F07178;">            启动磁盘读</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">第二块不在高速缓存中</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        为第二块获得缓冲区</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">算法getblk</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区数据有效</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            释放缓冲区</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">算法brelse</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            启动磁盘读</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">第一块本来就在高速缓冲中</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        读第一块（算法bread)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">第一个缓冲区包含有效数据的事件</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="_2-4-2-bwrite算法" tabindex="-1">2.4.2 bwrite算法 <a class="header-anchor" href="#_2-4-2-bwrite算法" aria-hidden="true">#</a></h3><p>bwrite算法是写磁盘块的算法。与前面类似。</p><div class="language-c"><button class="copy"></button><span class="lang">c</span><pre><code><span class="line"><span style="color:#A6ACCD;">算法 bwrite</span><span style="color:#676E95;"> // 写块</span></span>
<span class="line"><span style="color:#A6ACCD;">输入： 缓冲区</span></span>
<span class="line"><span style="color:#A6ACCD;">输出： 无</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    启动磁盘写</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">if</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">IO同步</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">等待IO完成事件</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">        释放缓冲区（算法brelse）</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">缓冲区标记延迟写</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">        为缓冲区做标记以放到空闲表头部</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;">// 这里标记就是前面&quot;旧&quot;.</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>最后，因为有提前读与延迟写磁盘块这两个异步I/O操作，所以才发生内核从一个中断处理程序中调用brelse的情形。由于brelse要把缓冲区放到空闲表上，所以它必须在对缓冲区空闲表进行操作的任何过程中都禁止中断。</p><p>关于缓冲区优点参见原书3.5。</p></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-37ebe389 data-v-a54a85bd><!----><div class="prev-next" data-v-a54a85bd><div class="pager" data-v-a54a85bd><a class="pager-link prev" href="/note/Unix/" data-v-a54a85bd><span class="desc" data-v-a54a85bd>Previous page</span><span class="title" data-v-a54a85bd>目录</span></a></div><div class="has-prev pager" data-v-a54a85bd><a class="pager-link next" href="/note/Unix/%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA.html" data-v-a54a85bd><span class="desc" data-v-a54a85bd>Next page</span><span class="title" data-v-a54a85bd>文件内部表示</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-c6a644e1 data-v-9f24cc86><div class="container" data-v-9f24cc86><p class="message" data-v-9f24cc86>Released under the MIT License.</p><p class="copyright" data-v-9f24cc86>Copyright © 2019-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"how-to-read_index.md\":\"80ea7abd\",\"how-to-read_readlist.md\":\"befd0b49\",\"unix_index.md\":\"584853b7\",\"unix_数据缓冲区.md\":\"fa45b0bd\",\"unix_文件的内部表示.md\":\"f025079b\",\"doc_index.md\":\"a5af3f44\",\"doc_obsidian-seseimage.md\":\"136ff97a\",\"doc_xgplayer.md\":\"ccaae490\",\"index.md\":\"c9f98061\",\"rnote_index.md\":\"a07d0d93\"}")</script>
    <script type="module" async src="/note/assets/app.e06fd376.js"></script>
    
  </body>
</html>